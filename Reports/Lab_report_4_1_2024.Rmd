---
title: "HCD Simulations Write Up"
author: "Audrey Fu Lab"
date: "2024-03-07"
output:
 pdf_document:
   keep_tex: true
   number_sections: true
always_allow_html: true
header-includes:
  - \usepackage{float}
  - \usepackage{multirow}
  - \usepackage{lastpage}
  - \usepackage{fancyhdr}
  # - \pagenumbering{gobble}
  - \pagestyle{fancy}
bibliography: C:/Users/Bruin/Desktop/Research Assistantship/Thesis Proposal Defense/proposal_references.bib
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=12, fig.height=10, fig.pos = "H")
#knitr::opts_chunk$set(list(echo = FALSE, eval = FALSE))
library(kableExtra)
library(knitr)
library(latex2exp)
library(gridExtra)
library(ggpubr)
library(ggthemes)
library(plyr)
basepath = 'C:/Users/Bruin/Documents/GitHub/HGRN_repo/Simulated Hierarchies/'

library(ggpubr)
tab = read.csv(paste0(basepath, 'DATA/Toy_examples/Intermediate_examples/Results/MASTER_results.csv'))




```

\section*{Data Simulation}

\subsection*{Simulating the network}
We adopt a top-down approach to simulate hierarchical networks, considering various simulation parameters such as graph sparsity, noise, and the architecture of the super-level graph(s), including small-world, scale-free, and random graph networks [@watts1998collective; @barabasi2003scale].

Our simulations focus on basic hierarchies comprising one or two hierarchical layers. Two-layer networks mirror classical community detection on graphs, where our aim is to recover the true community labels from a given graph. Meanwhile, three-layer networks present a more intricate scenario, where the bottom layer of the hierarchy contains two levels of community structure. Here, the top level corresponds to the nodes at the uppermost layer of the hierarchy, and the middle level consists of communities nested within the top-level communities. The objective with these networks is to identify both sets of community partitions.
	
In each hierarchy, for fully connected networks, we initiate by simulating $n_{\text{top}}$ top-level nodes, adhering to a directed small-world, random graph, or scale-free network architecture [@watts1998collective; @barabasi2003scale]. In cases where the network is disconnected, we simply simulate $n_{\text{top}}$ disconnected nodes. For networks with three hierarchical layers, we then generate a subnetwork of $n_{\text{middle}}$ nodes from each top-layer node, adhering to the network structure utilized at the top level. If the network is fully connected, we apply a probability $p_\text{between}$ to the nodes from different top-level communities being connected. 

The final step in all hierarchies is to generate the nodes in the observed (bottom) layer of the hierarchy. For each top-layer or middle-layer node, we generate a subnetwork of $n_{\text{bottom}}$ nodes under the same subnetwork structure as the previous layers, and we apply a probability $p_\text{between}$ for nodes from different communities to share an edge.

\subsection*{Simulating gene expression}

Once we simulate a hierarchical graph, we utilize this hierarchy to generate the node-feature matrix, which depicts the expression of $N$ genes across $p$ samples. Here, $N$ denotes the number of nodes in the observed (bottom) layer of the hierarchy, and its range is governed by $a^{\ell+1}<N<a\times b^\ell$, where $\ell$ signifies the number of hierarchical layers.

We simulate the node-feature matrix using the topological order the observed level graph. We start by generating the features of nodes that have no parental input. We refer to these nodes as origin nodes. All origin nodes are simulated from a normal distribtion with mean $0$ and standard deviation $\sigma$. All other nodes are simulated from a normal distribution centered at the mean of their parent nodes and with standard deviation $\sigma$. 

\section*{Datasets}
	
We consider three sets of hierarchical networks which represent varying difficulty levels for inference:
	
\begin{itemize}
  \item[1.] \textbf{Complex networks} - - used for final simulation assessment - \textbf{Table 1-3}
  \item[2.] \textbf{Intermediate networks} - used for investigative model tuning and performance assessment - \textbf{Table 4}
  \item[3.] \textbf{Simple networks} - used for code implementation and debugging - \textbf{Table 5}
\end{itemize}

\section*{Application to Intermediate Networks}

A summary of the intermediate networks can be found in \textbf{Table 4}. The intermediate networks dataset consists of three layer networks of small world, scale free, and random graph architectures that are less complex then the three layer networks in the \textbf{Complex networks} dataset. Each of these networks has $5$ super layer nodes, $15$ middle layer nodes and approximately $300$ bottom layer nodes. We primarily use this dataset to investigate the behavior of the HCD method when applied to 3-layer network.   

\section*{Preliminary Findings}


\newpage 

\section*{Tables}

```{r, echo=F, message=F, warning=F}

complex_net_stats = read.csv('C:/Users/Bruin/Documents/GitHub/HGRN_repo/Simulated Hierarchies/DATA/network_statistics.csv')[,-1]

complex_net_stats$modularity_top = round(complex_net_stats$modularity_top, 3)
complex_net_stats$avg_node_degree_top = round(complex_net_stats$avg_node_degree_top, 3)
complex_net_stats$avg_connect_within_top = round(complex_net_stats$avg_connect_within_top, 3)
complex_net_stats$avg_connect_between_top = round(complex_net_stats$avg_connect_between_top, 3)
complex_net_stats$modularity_middle = round(complex_net_stats$modularity_middle, 3)
complex_net_stats$avg_node_degree_middle = round(complex_net_stats$avg_node_degree_middle, 3)
complex_net_stats$avg_connect_within_middle = round(complex_net_stats$avg_connect_within_middle, 3)
complex_net_stats$avg_connect_between_middle = round(complex_net_stats$avg_connect_between_middle, 3)

df = rbind.data.frame(c('Subgraph type','Connection type','Layers','Standard deviation','Nodes per layer','Edges per layer','Subgraph probability','Sample size', 'Modularity (top)', 'Average node degree top', 'Avg connections within top communities','Avg. connections between top communities', 'Modularity (middle)', 'Average node degree middle', 'Avg connections within middle communities', 'Avg connections between middle communities'), complex_net_stats)

kable(t(df[1:9,]), format = 'latex', digits = 2, row.names = F, col.names = c('Value', paste0('Network', c(1:8))),
                                                                                    booktabs = T,
      caption = 'Summary statistics for all small world networks in the complex networks datset')%>%kable_styling(latex_options = c("striped", "hold_postion"),font_size = 10)%>%kable_styling(font_size = 9)%>%column_spec(1, '6em')%>%column_spec(2:9, '4em')

```


```{r, echo=F, message=F, warning=F}

kable(t(df[c(1, 10:17),]), format = 'latex', digits = 2, row.names = F, col.names = c('Value', paste0('Network', c(1:8))),
                                                                                    booktabs = T,
      caption = 'Summary statistics for all scale free networks in the complex networks datset')%>%kable_styling(latex_options = c("striped", "hold_postion"),font_size = 10)%>%kable_styling(font_size = 9)%>%column_spec(1, '6em')%>%column_spec(2:9, '4em')

```



```{r, echo=F, message=F, warning=F}

kable(t(df[c(1, 18:25),]), format = 'latex', digits = 2, row.names = F, col.names = c('Value', paste0('Network', c(1:8))),
                                                                                    booktabs = T,
      caption = 'Summary statistics for all random graph networks in the complex networks datset')%>%kable_styling(latex_options = c("striped", "hold_postion"),font_size = 10)%>%kable_styling(font_size = 9)%>%column_spec(1, '6em')%>%column_spec(2:9, '4em')

```

\clearpage
\newpage
```{r, echo=F, message=F, warning=F}

inter_net_stats = read.csv('C:/Users/Bruin/Documents/GitHub/HGRN_repo/Simulated Hierarchies/DATA/Toy_examples/Intermediate_examples/intermediate_examples_network_statistics.csv')[,-1]

inter_net_stats$modularity_top = round(inter_net_stats$modularity_top, 3)
inter_net_stats$avg_node_degree_top = round(inter_net_stats$avg_node_degree_top, 3)
inter_net_stats$avg_connect_within_top = round(inter_net_stats$avg_connect_within_top, 3)
inter_net_stats$avg_connect_between_top = round(inter_net_stats$avg_connect_between_top, 3)
inter_net_stats$modularity_middle = round(inter_net_stats$modularity_middle, 3)
inter_net_stats$avg_node_degree_middle = round(inter_net_stats$avg_node_degree_middle, 3)
inter_net_stats$avg_connect_within_middle = round(inter_net_stats$avg_connect_within_middle, 3)
inter_net_stats$avg_connect_between_middle = round(inter_net_stats$avg_connect_between_middle, 3)

df = rbind.data.frame(c('Subgraph type','Connection type','Layers','Standard deviation','Nodes per layer','Edges per layer','Subgraph probability','Sample size', 'Modularity (top)', 'Average node degree top', 'Avg connections within top communities','Avg. connections between top communities', 'Modularity (middle)', 'Average node degree middle', 'Avg connections within middle communities', 'Avg connections between middle communities'), inter_net_stats)

kable(t(df), format = 'latex', digits = 2, row.names = F, col.names = c('Value', paste0('Network', c(1:6))),
                                                                                    booktabs = T,
      caption = 'Summary statistics for intermediate difficulty simulated networks.')%>%kable_styling(latex_options = c("striped", "hold_postion"),font_size = 10)%>%kable_styling(font_size = 10)%>%column_spec(1, '8em')
```



```{r, echo=F, message=F, warning=F}

toy_net_stats = read.csv('C:/Users/Bruin/Documents/GitHub/HGRN_repo/Simulated Hierarchies/DATA/Toy_examples/toy_examples_network_statistics.csv')[,-1]

toy_net_stats$modularity_top = round(toy_net_stats$modularity_top, 3)
toy_net_stats$avg_node_degree_top = round(toy_net_stats$avg_node_degree_top, 3)
toy_net_stats$avg_connect_within_top = round(toy_net_stats$avg_connect_within_top, 3)
toy_net_stats$avg_connect_between_top = round(toy_net_stats$avg_connect_between_top, 3)
toy_net_stats$modularity_middle = round(toy_net_stats$modularity_middle, 3)
toy_net_stats$avg_node_degree_middle = round(toy_net_stats$avg_node_degree_middle, 3)
toy_net_stats$avg_connect_within_middle = round(toy_net_stats$avg_connect_within_middle, 3)
toy_net_stats$avg_connect_between_middle = round(toy_net_stats$avg_connect_between_middle, 3)

df = rbind.data.frame(c('Subgraph type','Connection type','Layers','Standard deviation','Nodes per layer','Edges per layer','Subgraph probability','Sample size', 'Modularity (top)', 'Average node degree top', 'Avg connections within top communities','Avg. connections between top communities', 'Modularity (middle)', 'Average node degree middle', 'Avg connections within middle communities', 'Avg connections between middle communities'), toy_net_stats)

kable(t(df), format = 'latex', digits = 2, row.names = F, col.names = c('Value', paste0('Network', c(1:4))),
                                                                                    booktabs = T,
      caption = 'Summary statistics for simple simulated networks. These networks contain fewer than 100 nodes at the observed level and only cover small world subgraph architecture')%>%kable_styling(latex_options = c("striped", "hold_postion"),font_size = 10)%>%kable_styling(font_size = 10)%>%column_spec(1, '8em')
```

\clearpage
\newpage
```{r, echo=F, message=F, warning=F}

grid = expand.grid(`Input Graph` = unique(tab$input_graph),
                   `Graph Recon. Loss` = c('1 = on', '0 = off'),
                   `Attr. Recon. Loss` = c('False (on)', 'True (off)'),
                   `Modularity Weight` = c('1 = on', '0 = off'),
                   `Clust. Weight` = c('1 (middle), 1 (top)', '0.1 (middle), 1e-4 (top)'))

kable(grid, format = 'markdown', digits = 2, row.names = F, booktabs = T,
      caption = 'Simulation settings for intermediate difficulty networks. Each row represents a single simulation scenario applied to all 6 simulated networks given in Table 1')%>%kable_styling(latex_options = c("striped", "hold_postion"),font_size = 10)%>%kable_styling(font_size = 10)%>%column_spec(1, '8em')
```




\newpage
\section*{Figures}
```{r fig1, echo=F, message=F, warning=F, fig.height=8, fig.width=10}

longform = cbind.data.frame(metric = as.factor(c(rep('homogeneity', dim(tab)[1]),
                              rep('completeness', dim(tab)[1]),
                              rep('NMI', dim(tab)[1]))),
                            lambda_top = as.factor(rep(tab$Lambda_top, 3)),
                            lambda_middle = as.factor(rep(tab$Lambda_middle, 3)),
                            network = as.factor(rep(tab$Network_type, 3)),
                            input_graph = as.factor(rep(tab$input_graph, 3)),
                            gamma = as.factor(rep(tab$Gamma, 3)),
                            TOAL_loss = as.factor(rep(tab$TOAL_Loss, 3)),
                            resolution_top = as.factor(rep(tab$Resolution_top, 3)),
                            resolution_middle = as.factor(rep(tab$Resolution_middle, 3)),
                            Top.stats = c(tab$Top_homogeneity, tab$Top_completeness, tab$Top_NMI),
                            Mid.stats = c(tab$Middle_homogeneity, tab$Middle_Completeness, tab$Middle_NMI),
                            Louvain.top = c(tab$Louvain_homogenity_top, 
                                            tab$Louvain_completeness_top, 
                                            tab$Louvain_NMI_top),
                            Louvain.middle = c(tab$Louvain_homogenity_middle, 
                                               tab$Louvain_completeness_middle,
                                               tab$Louvain_NMI_middle))




longform.x = cbind.data.frame(method = c(rep(rep('HCD', dim(tab)[1]),3),
                                         rep(rep('Louvain', dim(tab)[1]),3)),
                              metric = as.factor(c(rep('homogeneity', dim(tab)[1]),
                                                   rep('completeness', dim(tab)[1]),
                                                   rep('NMI', dim(tab)[1]))),
                              TOAL = as.factor(rep(rep(tab$TOAL_Loss, 3),2)),
                              network = as.factor(rep(rep(tab$Network_type, 3),2)),
                              input_graph = as.factor(rep(rep(tab$input_graph, 3),2)),
                              performance.top = c(c(tab$Top_homogeneity, 
                                                    tab$Top_completeness, 
                                                    tab$Top_NMI),
                                                  c(tab$Louvain_homogenity_top, 
                                                    tab$Louvain_completeness_top, 
                                                    tab$Louvain_NMI_top)),
                              performance.middle = c(c(tab$Middle_homogeneity, 
                                                       tab$Middle_Completeness, 
                                                       tab$Middle_NMI),
                                                     c(tab$Louvain_homogenity_middle, 
                                                       tab$Louvain_completeness_middle,
                                                       tab$Louvain_NMI_middle)))



# comparing HCD with louvain on graph type 
A = ggplot(data = longform.x, aes(x = method, y = performance.top, fill = metric))+
  geom_boxplot()+
  xlab('Method')+
  ylab('Performance Top Layer')+
  facet_wrap(~network)+
  theme_classic2()+
  theme(legend.position = 'top')

B = ggplot(data = longform.x, aes(x = method, y = performance.middle, fill = metric))+
  geom_boxplot()+
  xlab('Method')+
  ylab('Performance Middle Layer')+
  facet_wrap(~network)+
  theme_classic2()+
  theme(legend.position = 'top')


ggarrange(A, B, nrow = 2, common.legend = T)
```



```{r, echo=F, message=F, warning=F, fig.height=8, fig.width=10}


# comparing HCD with louvain on input graph 
A = ggplot(data = longform.x, aes(x = method, y = performance.top, fill = metric))+
  geom_boxplot()+
  xlab('Method')+
  ylab('Performance Top Layer')+
  facet_wrap(~input_graph)+
  theme_classic2()+
  theme(legend.position = 'top')

B = ggplot(data = longform.x, aes(x = method, y = performance.middle, fill = metric))+
  geom_boxplot()+
  xlab('Method')+
  ylab('Performance Middle Layer')+
  facet_wrap(~input_graph)+
  theme_classic2()+
  theme(legend.position = 'top')


ggarrange(A, B, nrow = 1, common.legend = T)

```




```{r, echo=F, message=F, warning=F, fig.height=8, fig.width=10, fig.cap='Small world graphs'}
longform2 = cbind.data.frame(method = as.factor(c(rep('HCD', dim(longform)[1]), 
                                        rep('Louvain', dim(longform)[1]))),
                             metric = as.factor(rep(c(rep('homogeneity', dim(tab)[1]),
                                         rep('completeness', dim(tab)[1]),
                                         rep('NMI', dim(tab)[1])), 2)),
                  network = as.factor(rep(tab$Network_type, 6)),
                  input_graph = as.factor(rep(tab$input_graph, 6)),
                  gamma = as.factor(rep(tab$Gamma, 6)),
                  resolution_top = as.factor(rep(tab$Resolution_top, 6)),
                  resolution_middle = as.factor(rep(tab$Resolution_middle, 6)),
                  stats.top = c(longform$Top.stats, longform$Louvain.top),
                  stats.mid = c(longform$Mid.stats, longform$Louvain.top))
                  
                  
                  
                  
#Top level comparison
#smallworld network
lf1.1 = subset(longform2, network == 'small world')
A =ggplot(data = lf1.1, aes(x = method, y = stats.top, 
                             fill = metric))+
  geom_boxplot()+
  xlab('Method')+
  ylab('Top Layer Performance')+
  facet_wrap(~input_graph)+
  theme_classic2()+
  theme(legend.position = 'top', axis.text.x = element_text(angle = 90))


B =ggplot(data = lf1.1, aes(x = method, y = stats.mid, 
                         fill = metric))+
  geom_boxplot()+
  xlab('Method')+
  ylab('Middle Layer Performance')+
  facet_wrap(~input_graph)+
  theme_classic2()+
  theme(legend.position = 'top', axis.text.x = element_text(angle = 90))

ggarrange(A, B, nrow = 1, common.legend = T)

```


```{r, echo=F, message=F, warning=F, fig.height=8, fig.width=10, fig.cap='Scale free graphs'}
#scale free
lf1.2 = subset(longform2, network == 'scale free')
A = ggplot(data = lf1.2, aes(x = method, y = stats.top, 
                             fill = metric))+
  geom_boxplot()+
  xlab('Method')+
  ylab('Top Layer Performance')+
  facet_wrap(~input_graph)+
  theme_classic2()+
  theme(legend.position = 'top', axis.text.x = element_text(angle = 90))

B = ggplot(data = lf1.2, aes(x = method, y = stats.mid, 
                         fill = metric))+
  geom_boxplot()+
  xlab('Method')+
  ylab('Middle Layer Performance')+
  facet_wrap(~input_graph)+
  theme_classic2()+
  theme(legend.position = 'top', axis.text.x = element_text(angle = 90))

ggarrange(A, B, nrow = 1, common.legend = T)
```


```{r, echo=F, message=F, warning=F, fig.height=8, fig.width=10, fig.cap='random graphs'}
#random graph
lf1.3 = subset(longform2, network == 'random graph')
A = ggplot(data = lf1.3, aes(x = method, y = stats.top, 
                             fill = metric))+
  geom_boxplot()+
  xlab('Method')+
  ylab('Top Layer Performance')+
  facet_wrap(~input_graph)+
  theme_classic2()+
  theme(legend.position = 'top', axis.text.x = element_text(angle = 90))

B = ggplot(data = lf1.3, aes(x = method, y = stats.mid, 
                         fill = metric))+
  geom_boxplot()+
  xlab('Method')+
  ylab('Middle Layer Performance')+
  facet_wrap(~input_graph)+
  theme_classic2()+
  theme(legend.position = 'top', axis.text.x = element_text(angle = 90))

ggarrange(A, B, nrow = 1, common.legend = T)
```








\bibliographystyle{unsrt}
	\bibliography{C:/Users/Bruin/Desktop/Research Assistantship/Thesis Proposal Defense/proposal_references.bib}

\newpage
\section*{References}
