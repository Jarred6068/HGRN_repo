---
title: "HCD Simulations Write Up"
author: "Audrey Fu Lab"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
  pdf_document: default
always_allow_html: true
bibliography: C:/Users/Bruin/OneDrive/Desktop/Research Assistantship/Thesis Proposal
  Defense/proposal_references.bib
number_sections: false
---

```{r setup, include=FALSE}

library(ggplot2)
library(ggthemes)
library(ggpubr)
library(latex2exp)
library(gridExtra)
library(knitr)
library(kableExtra)
library(dplyr)

knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=12, fig.height=8)

```


# Data Simulation {-}

### Simulating networks {-}
We adopt a top-down approach to simulate hierarchical networks, considering various simulation parameters such as graph sparsity, noise, and the architecture of the super-level graph(s), including small-world, scale-free, and random graph networks [@watts1998collective; @barabasi2003scale].

Our simulations focus on basic hierarchies comprising one or two hierarchical layers. Two-layer networks mirror classical community detection on graphs, where our aim is to recover the true community labels from a given graph. Meanwhile, three-layer networks present a more intricate scenario, where the bottom layer of the hierarchy contains two levels of community structure. Here, the top level corresponds to the nodes at the uppermost layer of the hierarchy, and the middle level consists of communities nested within the top-level communities. The objective with these networks is to identify both sets of community partitions.
	
In each hierarchy, for fully connected networks, we initiate by simulating $N_{\text{top}}$ top-level nodes, adhering to a directed small-world, random graph, or scale-free network architecture [@watts1998collective; @barabasi2003scale]. In cases where the network is disconnected, we simply simulate $N_{\text{top}}$ disconnected nodes. For networks with three hierarchical layers, we then generate a subnetwork of $N_{\text{middle}}$ nodes from each top-layer node, adhering to the network structure utilized at the top level. If the network is fully connected, we apply a probability $p_\text{between}$ to the nodes from different top-level communities being connected. 

The final step in all hierarchies is to generate the nodes in the observed (bottom) layer of the hierarchy. For each top-layer or middle-layer node, we generate a sub-network of $N_{\text{bottom}}$ nodes under the same sub-network structure as the previous layers, and we apply a probability $p_\text{between}$ for nodes from different communities to share an edge.


### Simulating gene expression {-}

Once we simulate a hierarchical graph, we utilize this hierarchy to generate the node-feature matrix, which depicts the expression of $N$ genes across $d$ samples. Here, $N$ denotes the number of nodes in the observed (bottom) layer of the hierarchy.

We simulate the node-feature matrix using the topological order of the observed level graph. We start by generating the features of nodes that have no parental input. We refer to these nodes as *origin* nodes. All origin nodes are simulated from a normal distribution with mean $0$ and standard deviation $\sigma$. All other nodes are simulated from a normal distribution centered at the mean of their parent nodes and with standard deviation $\sigma$. 

# Hierarchical Commuity Detection (HCD) Overview {-}

Our HCD method consists of two modules:

  1. A graph autoencoder based on the architecture proposed by @salehi2019graph which utilizes graph attention layers such as those first introduced by @velivckovic2017graph (See most recent version of pseudocode for details). In our applications, we incorporate multi-head attention in all encoder and decoder layers to expand model learning capacity. The graph autoencoder module takes a set of node attributes ${\bf X}\in\mathbb{R}^{N \times d}$ and an adjacency matrix ${\bf A}_{ij}\in[0,1]$ defining the relationships between the node as input and learns a low dimensional embedding ${\bf Z} \in \mathbb{R}^{N \times q}$ of the network and attributes. This embedding is then used to reconstruct the node attributes and adjacency matrix under a separate loss function for each.  
  
  2. The second module of HCD takes the embeddings ${\bf Z}$ generated by the autoencoder and applies a multilevel community detection process. This module first applies the function $f_{top}$ which partitions the data into $k$ groups. The function $f_{top}$ can be either (i) the $SoftKMeans$ layer described by [@Falkner2022] or a neural layer such as 
  
  **Simple Linear Layer**:
  
  $${\bf P} = f_{top}({\bf Z}) = \text{Softmax}(\theta({\bf ZW} + {\bf b}))$$
The above example is a simple fully connected layer where ${\bf W} \in \mathbb{R}^{N \times k}$ is a matrix of parameters, ${\bf b} \in \mathbb{R}^N$ is a bias parameter vector and $\theta$ is an activation function such as the $ReLU$ function. 

Alternative types of layer can also be used such heuristic KMeans or other GNN-type layers such as GraphSAGE convolution [@]. 

  **Using gradient optimized SoftKMeans**
  
  $${\bf P} = f_{top}({\bf Z}) = \text{Softmax}(g({\bf Z})) $$
where $g()$ represents the KMeans algorithm [@Falkner2022]
  
  **GraphSAGE Convolutional Layer**
  
  $${\bf p}_v = f_{top}({\bf z}_v) = \text{Softmax}\left(\theta\left( W Â· CONCAT\big({\bf z}_v,\ AGGREGATE\big({\bf z}_u : u \in N(v) \big) \big) \right)\right)$$
where ${\bf p}_v$ is the soft assignment of node $v$
  
# Simulation Study

Here we describe the settings for three different sets of simulations. For each set of simulations, we simulated hierarchical gene networks consisting of 5 top level nodes/communities, 15 middle level nodes/communities and 300 nodes/genes at the observed level of the hierarchy. We simulate networks for all three graph types (small world, scale free or random graph) with the nodes at the top level of the hierarchy either all connected or all disconnected. We also simulated nodes under two levels of noise with noise set to either $\sigma = 0.1$ or $\sigma = 0.5$. Additionally, we sample the probability for edges within and between node communities at the middle layer and bottom level from the uniform distributions


```{r simtab1, echo = FALSE, message=FALSE, warning=FALSE}

x = cbind.data.frame(Layer = c("Middle", "", "Bottom", ""),
                     Connection = c("Within", "Between", "Within", "Between"),
                     `Sampling Distibution` = rep('Uniform', 4),
                     `Lower Bound` = c(0.01, 0.01, 0.001, 0.001),
                     `Upper Bound` = c(0.15, 0.15, 0.05, 0.05))
kable(x, format = 'latex', booktabs = T)

```

Each combination of parameters (graph type, connectivity, and noise) is replicated multiple times. 




To evaluate the performance of HCD, we conducted a series of simulation studies under various conditions. Below, we describe each simulation condition in detail:

## Linear-GT
- **Description**: HCD employs linear neural layers for both the top and middle layer partitions. 
- **Setup**: 
  - Top layer output size: 5 (ground truth number of communities).
  - Middle layer output size: 15 (ground truth number of communities).
- **Purpose**: To assess performance when prior information about the true community structure is provided.

## SoftKmeans-15-5
- **Description**: SoftKmeans is used to perform the top partitioning, while the middle layer employs a linear neural network.
- **Setup**: 
  - Top layer: \( k = 5 \) (ground truth number of communities).
  - Middle layer output size: 15 (ground truth number of communities).
- **Purpose**: To compare the performance of SoftKmeans with the HCD hierarchical framework.

## Linear-64-64
- **Description**: Linear neural layers are used for both the top and middle layers without incorporating prior information about community structure.
- **Setup**: 
  - Top layer output size: 64.
  - Middle layer output size: 64.
- **Purpose**: To evaluate HCD's ability to detect communities in the absence of ground truth information.

## Linear-BH-64
- **Description**: Linear neural layers are used for both layers, with the top layer leveraging the Bethe Hessian estimate for the number of communities.
- **Setup**: 
  - Top layer output size: Bethe Hessian estimate of the number of communities based on the input graph.
  - Middle layer output size: 64.
- **Purpose**: To examine the effectiveness of incorporating the Bethe Hessian estimate in guiding top-layer partitioning.

## GATCONV-BH-64
- **Description**: Graph attention layers (GAT) are used for both the top and middle layers.
- **Setup**: 
  - Top layer output size: Bethe Hessian estimate of the number of communities.
  - Middle layer output size: 64.
- **Purpose**: To evaluate the impact of using graph attention (GAT) in hierarchical partitioning.

## SAGECONV-BH-64
- **Description**: GraphSAGE convolutional layers are employed for both the top and middle layers.
- **Setup**: 
  - Top layer output size: Bethe Hessian estimate of the number of communities.
  - Middle layer output size: 64.
- **Purpose**: To investigate the utility of GraphSAGE in hierarchical clustering.

## SAGECONV-BH-64-DW
- **Description**: Similar to the SAGECONV-BH-64 setup, but with adjusted clustering loss function hyperparameters.
- **Setup**: 
  - Top layer output size: Bethe Hessian estimate of the number of communities.
  - Middle layer output size: 64.
  - Additional modification: Clustering component hyperparameters in the loss function are downweighted.
- **Purpose**: To determine if downweighting clustering loss hyperparameters improves performance.

---

# Summary

These simulation conditions are designed to rigorously assess the performance of HCD under diverse scenarios. By varying the partitioning methods, output sizes, and use of prior information, we aim to gain insights into HCD's robustness, adaptability, and effectiveness in uncovering hierarchical community structures in genomic data.



```{r paramtab1, echo = FALSE, message=FALSE, warning=FALSE}

params <- data.frame(
  Parameter = c("patience", "method", "batch learning", "batch_size", "AE operator", 
                "COMM operator", "attn. heads", "dropout", "Layer Normalization", 
                "AE hidden sizes", "Comm output size (Top)", "Comm output size (Middle)", 
                "$\\gamma$", "$\\delta$", "$\\lambda$", "learning rate", "Max epochs", 
                "Graph correlation cutoff", "% Training", "% Testing"),
  
  Value = c(10, "top down", "TRUE", 64, "GATv2Conv","Linear", 5, 0.2, "TRUE", "[256, 128]", 
            5, 15, 1, 1, "[1, 1]", 1e-3, 200, 0.2, 80, 20)
)

# Create kable table
kable(params,
      format = "latex",
      col.names = c("Parameter", "Value"),
      caption = "Simulation Set 1 model parameter settings") %>%
  kable_styling(full_width = FALSE)

```


### Evaluating performance {-}

We evaluate the performance of our HCD method using three graph-based clustering metrics:

   1. **homogeneity** evaluates the degree to which each predicted community contains only data points from a single true community, indicating how well the algorithm avoids mixing different groups. Thus, homogeneity tends to be high if resolved communities contain only members of the same true community.
   
   2. **completeness** assesses the extent to which all data points that belong to the same true
community are correctly assigned to a single predicted community. Thus completeness is always high if all members of the same true communities end up in the same resolved community even if several true communities are allocated together. 
   
   3. **NMI** Normalized Mutual Information (NMI) is a weighted average of the Completeness and Homogeneity two metrics. 
   
   4. **ARI** The Adjusted Rand Index (ARI) is a metric that measures the similarity between two different clusterings of the same data, correcting for the chance of random agreement. It ranges from -1 to 1, where 1 indicates perfect agreement between the clusterings, 0 represents random labeling, and negative values indicate less agreement than expected by chance. 


In all simulations we compare HCD with two commonly used heuristic methods:

  * **Louvain Method**: This widely used community detection algorithm optimizes modularity by iteratively reassigning nodes between communities and merging communities. It automatically determines the number of communities and is highly efficient for processing large networks. In all simulations, we apply the Louvain method to the estimated adjacency matrix, which is derived from the correlation matrix of the node features. The resulting community predictions are compared to the ground truth for both the top and middle layers of the simulated hierarchy.

  * **Hierarchical Clustering using Ward's Distance (HC)**: This agglomerative clustering approach iteratively merges clusters to minimize the increase in within-cluster variance. Ward's method tends to produce compact, spherical clusters and generates a dendrogram representing the full hierarchical structure of the data. In all simulations, HC is applied to the simulated gene expression data (node feature matrix). The optimal community predictions are determined by identifying the best cutting point on the dendrogram, aligning with the ground truth clusters (five clusters and 15 clusters).



 
### Ways of Estimating K

There are several classical approaches to estimating the number of communities, $k$, in unsupervised learning. Among these, two commonly adopted data-driven approaches are the **Elbow Method** and the optimization of a cluster quality metric, such as the **Silhouette Score**. Additionally, we also consider a graph-based approach known as the **Bethe Hessian estimate**.

- **Elbow Method**:  
  The Elbow Method identifies the optimal number of clusters by plotting the clustering cost (e.g., within-cluster sum of squares) against the number of clusters, $k$. The "elbow" point, where the rate of decrease in the cost slows significantly, is taken as the optimal $k$. This method assumes that beyond this point, adding more clusters does not improve clustering quality significantly.

- **Silhouette Method**:  
  The Silhouette Method evaluates the quality of clustering by measuring how similar data points are to their assigned cluster (cohesion) compared to other clusters (separation). The Silhouette score ranges from -1 to 1, where higher values indicate better-defined clusters. The optimal $k$ is the value that maximizes the average Silhouette score across all data points.

- **Bethe Hessian**:  
  The Bethe Hessian is a graph-based method for estimating the number of communities in a network. It involves constructing the Bethe Hessian matrix ${\bf B}_\eta = (\eta^2 - 1){\bf I} + {\bf D} - \eta {\bf A}$, where $A$ is the adjacency matrix, $D$ is the degree matrix, and $\eta$ is a regularization parameter. The number of negative eigenvalues of $H(r)$ provides an estimate of the number of communities. This approach leverages spectral properties of the graph to identify structural groupings. According to [@]

  
### Points to investigate


The Hierarchical Community Detection (HCD) algorithm performs poorly on the top layer of the hierarchy, despite the clear community structure at this level especially in the case of the disconnected networks. This observation warrents further investigation into the model dynamics to determine why the community structure clearly reflected in embeddings is not also captured by the loss function. 


- To help debug the issue noted above, we generated a small world disconnected network with 300 bottom layer nodes, 15 middle layer communities and 5 top layer communities (see Image 1). The plot of the adjacency matrix and heatmap of the data correlations clearly reflects the imposed community structure. This Example will be used throughout the debugging process described below.

![**Figure 1**: Heatmap of the correlations in the data and true adjacency matrix for a randomly generated example small world disconnected network with standard deviation 0.1 and intermediate size (300 nodes). This example was used to debug the model. ](C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Example_graph/heatmaps.png)


#### Debugging to determine model prediction disparity:

Using the example network shown above, we debugged each stage of training HCD investigating both the loss calculation and visually determining whether the computed probabilities and intermediate steps accurately reflect community structure captured in embeddings produced by the autoencoder GATE.

The clustering loss for the $\ell^{th}$ hierarchical layer is computed as:

\[{\bf D}_\ell = {\bf X}^T - {\bf M}_\ell {\bf P}_\ell^T \]

\[ L_{C_\ell} = tr\left(\sqrt{\text{diag}({\bf D}_\ell^T{\bf D}_\ell)}\right) \]

Where ${\bf D}_\ell \in \mathbb{R}^{n \times N_\ell}$, ${\bf P}_\ell \in \mathbb{R}^{N \times k_\ell}$, and 

\[ {\bf M}_\ell = {\bf X}^T {\bf P}_\ell \cdot \left({\bf 1}_N^T {\bf P}_\ell\right)^{-1} \in \mathbb{R}^{n \times k_\ell} \]

are the centroids for the community predictions in the $\ell^{th}$ hierarchical layer. 

In general, this calculation seems consistent with the results of the model. The issue appears to be that the steps converting the embeddings to logits and eventually probabilities via softmax are getting distorted. 

Recall that HCD consists of two modules:
- 1. An autoencoder which produces a an embedding $\bf Z$
- 2. A prediction model which converts the embedding into logits which capture model structure and then converts these logits into pseudo-probabilities vias the softmax activation function. This is the standard deep learning procedure for multiclass classification. 

The previous framework for the prediction model is described in detail mathematically below:

#### Previous Output Layer Framework

The embeddings ${\bf M}$ were computed as

\[ {\bf M} = \text{LeakyReLU}({\bf Z} {\bf W}_{out} + \beta_{out}) \]

where ${\bf Z}\in\mathbb{R}^{N \times q}$ is the input embedding from GATE, ${\bf M}\in\mathbb{R}^{N \times k}$ is the output embedding, and ${\bf W}\in\mathbb{R}^{q \times k}$ is a matrix of learnable parameters. 

The embedding ${\bf M}$ is then normalized using an element-wise affine: 

\[ {\bf H} = \text{LayerNorm}({\bf M}) = \frac{{\bf M}_{ij} - \mathbb{E}[{\bf M}_i]}{\sqrt{\text{Var}[{\bf M}_i] + \epsilon}}\cdot \gamma + \beta \]

The logits of the normalized embedding ${\bf H}$ are then converted to probabilities via softmax. However, a dropout layer was mistakenly applied to ${\bf H}$ before the softmax activation. While this dropout layer was intended as part of the original architecture, its placement was incorrect, as channels should not be zeroed out before the final activation of the output layer in any architecture.


\[{\bf P} = \text{Softmax}({\bf H}) \]

This framework has two distinct problems:

  - (i) Activation with LeakyReLU prior to normalizing embeddings and computing logits distorts the signals, washing out fine-grained community structure. This introduces artifacts in the top hierarchy layer.

  - (ii) In addition, an erroneously added dropout layer in output layers was directly responsible for misclassified nodes. 
  
See the example in **Figure 2** below which shows the embeddings at the first and last training epoch under this framework:

![**Figure 2** This example illustrates the GATE embedding ${\bf Z}$ and the output embedding $\bf M$ before and after activation and normalization under the previous prediction framework. As shown, activation and normalization distort the community signals, causing the model to incorrectly identify three communities instead of the five clearly visible in the GATE embedding $\bf Z$](C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Combined_previous_framework.png)





After inspecting the embeddings at each stage of this computation, it was observed that activating the embedding with LeakyReLU before converting logits distorted the signals in the data, essentially washing out fine-grained community structure. This led to artifact community signals in the top layer of the hierarchy. Instead, we seek to address this fundamental issue in the prediction model using the following revised framework:


#### Revised Framework For Output Layer

A new intermediate embedding {\bf M} is computed

\[ {\bf M} = {\bf Z} {\bf W}_{1} + \beta_1 \]

\[{\bf M}_{norm} = \text{LayerNorm}({\bf M}) \] 

where ${\bf M}\in\mathbb{R}^{N \times q}$ is an intermediate output embedding, and ${\bf W}\in\mathbb{R}^{q \times q}$ is a matrix of learnable parameters that casts $\bf Z$ to the same dimension. Again, ${\bf M}$ is normalized using an element-wise affine: 

\[ H = \text{LeakyReLU}({\bf M}_{norm}) \]

$\bf H$ is then converted to the output embedding using a single fully connected layer\

\[ {\bf O} = {\bf H}{\bf W}_{out} + \beta_{out} \]

\[{\bf P} = \text{Softmax}({\bf O}) \]

This revised framework eliminates the activation and normalization of embeddings before computing logits, removes inappropriate layer dropout, and ensures that the output embedding effectively shifts the logits to the appropriate embedding space. These adjustments preserve fine-grained and hierarchical community signals through three key changes:

1. **Compute the intermediate embedding ${\bf M}$**
  - Generate the intermediate representation from the input embedding.

2. **Normalize before activation:** 
  - Perform normalization on the embeddings prior to applying the LeakyReLU activation. This ensures that the distribution remains consistent and is not distorted by the non-linear effects of LeakyReLU.

3. **Directly map to the output dimension:** 
  - Convert the final intermediate embedding to the output dimension using a fully connected layer, applied just before the softmax activation. This minimizes distortion and ensures proper alignment of the logits with the target space.




![This example illustrates the GATE embedding ${\bf Z}$ and the output embedding $\bf M$ before and after activation and normalization under the revised prediction framework. As shown, the revised framework produces an overall more informative intermediate embedding and removes distortion effects](C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Combined_revised_framework.png)


#Both-Linear 5, 15



```{r set1fig1, echo=F, message=F, warning=F, fig.cap="Hierarchical clustering performance for the top layer of the hierarchical for HCD, classical hierarchical clustering using Ward's Distance (HC) and the Louvain method. Each point represents the performance in homogeneity and completeness for a unique simulated hierarchy. The diagonal line represents 1 to 1 corresponds between completeness and homogeneity. Points that fall above the line represent clustering solutions that overgroup the true communities while points that fall below the line represent clusters that break up the true communities. Points on the diagonal line represent a better clustering solution", eval=FALSE}
fp = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET1/linear_layers_1_9_2025/'

data_top = read.csv(paste0(fp, 'combined_all_results_top.csv'))
data_mid = read.csv(paste0(fp, 'combined_all_results_middle.csv'))
netstats = read.csv(paste0(fp, 'combined_sim_results.csv'))

predcoms_top = NULL
predcoms_middle = NULL

for (i in 1:length(netstats$Number_Predicted_Comms)){
  str = netstats$Number_Predicted_Comms[i]
  nums <- scan(text = gsub("[\\(\\)]", "", str), sep = ",", quiet = TRUE)
  predcoms_top[i] = nums[1]
  predcoms_middle[i] = nums[2]
}
# Method 1: Using gsub and scan


# ggplot(data = netstats, aes(x = Louvain_Predicted_comms, y = Beth_Hessian_Comms, color = Max_Modularity))+
#   geom_point()

A = ggplot(data = data_top, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Top Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))
plot(A)

```


```{r set1fig2, echo=F, message=F, warning=F, fig.cap = "Hierarchical clustering performance for the middle layer of the hierarchical for HCD, classical hierarchical clustering using Ward's Distance (HC) and the Louvain method. Each point represents the performance in homogeneity and completeness for a unique simulated hierarchy. The diagonal line represents 1 to 1 corresponds between completeness and homogeneity. Points that fall above the line represent clustering solutions that overgroup the true communities while points that fall below the line represent clusters that break up the true communities. Points on the diagonal line represent a better clustering solution.", eval=FALSE}

A = ggplot(data = data_mid, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Middle Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))

plot(A)

```










#SoftKMeans-Linear-5,15


```{r set2fig1, echo=F, message=F, warning=F, fig.cap="HCD results for the top layer of the hierarchy. In this simulation set, SoftKMeans is used to partition the top layer of the hierarchy. The output size for $k_{top} = 5$ and $k_{middle} = 15$ - the ground truth", eval=FALSE}
fp2 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET1/softkmeans_1_9_2025/'

data_top2 = read.csv(paste0(fp2, 'combined_all_results_top.csv'))
data_mid2 = read.csv(paste0(fp2, 'combined_all_results_middle.csv'))


A = ggplot(data = data_top2, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Top Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))
plot(A)

```


```{r set2fig2, echo=F, message=F, warning=F, fig.cap = "", eval = FALSE}

A = ggplot(data = data_mid2, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Middle Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))

plot(A)

```






#Both-Linear-BH-64
```{r, echo=F, message=F, warning=F, fig.cap="", eval = FALSE}
fp33 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET1/linear_layers_unk_k_1_9_2025/'

data_top433 = na.omit(read.csv(paste0(fp33, 'combined_all_results_top.csv')))
data_mid33 = na.omit(read.csv(paste0(fp33, 'combined_all_results_middle.csv')))


A = ggplot(data = data_top33, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Top Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))
plot(A)

```

```{r, echo=F, message=F, warning=F, fig.cap = "HCD results for the middle layer using Linear prediction layers and the bethe hessian to estimate the number of communities $k$.", eval=FALSE}

A = ggplot(data = data_mid33, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Middle Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))

plot(A)

```











```{r, echo=F, message=F, warning=F, fig.cap="", eval=FALSE}
#Both-Linear-64,64
fp55 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET1/linear_layers_both_64_1_9_2025/'

data_top55 = na.omit(read.csv(paste0(fp55, 'combined_all_results_top.csv')))
data_mid55 = na.omit(read.csv(paste0(fp55, 'combined_all_results_middle.csv')))


A = ggplot(data = data_top55, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Top Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))
plot(A)

```

```{r, echo=F, message=F, warning=F, fig.cap = "", eval=FALSE}

A = ggplot(data = data_mid55, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Middle Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))

plot(A)

```






```{r, echo=F, message=F, warning=F, fig.cap="HCD results for the top layer using SAGECONV prediction layers and bethe hessian to estimate the number of communities $k$.", eval=FALSE}

#Both-SAGECONV-BH,64
fp44 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET2/SAGECONV_1_9_2025/'

data_top44 = na.omit(read.csv(paste0(fp44, 'combined_all_results_top.csv')))
data_mid44 = na.omit(read.csv(paste0(fp44, 'combined_all_results_middle.csv')))


A = ggplot(data = data_top44, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Top Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))
plot(A)

```



```{r, echo=F, message=F, warning=F, fig.cap = "HCD results for the middle layer using SAGECONV prediction layers and the bethe hessian to estimate the number of communities $k$.", eval=FALSE}

A = ggplot(data = data_mid44, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Middle Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))

plot(A)

```

















```{r, echo=F, message=F, warning=F, fig.cap="HCD results using SAGECONV prediction layers using bethe hessian to estimate the number of communities $k$. In addition, the loss hyperparameters for the clustering component have been downweighted $\\lambda_{top = 1e-3}$ and $\\lambda_{middle} = 1e-2", eval=FALSE}

#Both-SAGECONV-BH,64-DW
fp4 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET2/SAGECONV_DW_1_9_2025/'

data_topscdw = na.omit(read.csv(paste0(fp4, 'combined_all_results_top.csv')))
data_midscdw = na.omit(read.csv(paste0(fp4, 'combined_all_results_middle.csv')))


A = ggplot(data = data_topscdw, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Top Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))
plot(A)

```



```{r, echo=F, message=F, warning=F, fig.cap = "", eval = FALSE}

A = ggplot(data = data_midscdw, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Middle Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))

plot(A)

```















```{r, echo=F, message=F, warning=F, fig.cap="HCD results using SAGECONV prediction layers using bethe hessian to estimate the number of communities $k$. In addition, the loss hyperparameters for the clustering component have been downweighted $\\lambda_{top = 1e-3}$ and $\\lambda_{middle} = 1e-2", eval=FALSE}

#Both-GATCONV-BH,64
fp77 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET2/GATCONV_v2_unk_k_1_9_2025/'

data_top_gc_bh64 = na.omit(read.csv(paste0(fp77, 'combined_all_results_top.csv')))
data_mid_gc_bh64 = na.omit(read.csv(paste0(fp77, 'combined_all_results_middle.csv')))


A = ggplot(data = data_top_gc_bh64, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Top Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))
plot(A)

```



```{r, echo=F, message=F, warning=F, fig.cap = "", eval=FALSE}

A = ggplot(data = data_mid_gc_bh64, aes(x = Homogeneity, y = Completeness, color = Method, shape = connection_type))+
  geom_abline(slope = 1, intercept = 0, linewidth = 1)+
  geom_point(size = 2)+
  scale_x_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  facet_wrap(~subgraph_type)+
  theme_bw()+
  ggtitle('Middle Layer Clustering Performance')+
  theme(axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = 'top', 
        legend.text = element_text(size = 10))

plot(A)

```





















```{r, echo=FALSE, message=FALSE, warning=FALSE}

#Linear-GT (15, 5)
fp1 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET1/linear_layers_1_9_2025/'
#SoftKmeans top (15,5)
fp2 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET1/softkmeans_1_9_2025/'
#Linear_64,64
fp3 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET1/linear_layers_both_64_1_9_2025/'
#Linear_BH,64
fp4 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET1/linear_layers_unk_k_1_9_2025/'
#GATCONV_BH,64
fp5 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET2/GATCONV_v2_unk_k_1_9_2025/'
#SAGECONV_BH,64
fp6 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET2/SAGECONV_1_9_2025/'
#SAGECONV_BH,64-DW
fp7 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_3_2025/Output/Intermediate_applications/SET2/SAGECONV_DW_1_9_2025/'




read_data = function(fp){
  topres = na.omit(read.csv(paste0(fp, 'combined_all_results_top.csv')))
  midres = na.omit(read.csv(paste0(fp, 'combined_all_results_middle.csv')))
  statres = na.omit(read.csv(paste0(fp, 'combined_sim_results.csv')))
  
  return(list(data.top = topres, data.mid = midres, stats = statres))
}








helper1 = function(netstats){
  
  predcoms_top = NULL
  predcoms_middle = NULL
  for (i in 1:length(netstats$Number_Predicted_Comms)){
    str = netstats$Number_Predicted_Comms[i]
    nums <- scan(text = gsub("[\\(\\)]", "", str), sep = ",", quiet = TRUE)
    predcoms_top[i] = nums[1]
    predcoms_middle[i] = nums[2]
  }
  
  return(list(top = mean(predcoms_top), middle = mean(predcoms_middle)))
  
}



fill.in.avg.table = function(subtable, substats, method, gtype, stdev, ctype){
  
  new.colnames = c('Method', 'Homogeneity', 'Completeness', 'NMI', 'ARI', 'Subgraph Type', 'Connection Type', 'StDev',
                 'Avg Node Degree (middle)', 'Avg WC Connections (middle)', 'Avg BC Connections (middle)', 
                 'Avg Node Degree (bottom)', 'Avg WC Connections (bottom)', 'Avg BC Connections (bottom)',
                 'Avg Number of Predicted Comms (top)', 'Avg Number of Predicted Comms (middle)', 'Avg Bethe-Hessian Comms')

  summary.table = data.frame(matrix(ncol = length(new.colnames), nrow = 1))
  colnames(summary.table) = new.colnames 
  
  
  summary.table$Method[1] = method    
  summary.table$ARI[1] = mean(subtable$ARI)
  summary.table$NMI[1] = mean(subtable$NMI)
  summary.table$Completeness[1] = mean(subtable$Completeness)
  summary.table$Homogeneity[1] = mean(subtable$Homogeneity)
  summary.table$`Subgraph Type`[1] = gtype
  summary.table$`Connection Type`[1] = ctype
  summary.table$StDev[1] = stdev
  summary.table$`Avg Node Degree (middle)`[1] = mean(subtable$avg_node_degree_top)
  summary.table$`Avg WC Connections (middle)`[1] = mean(subtable$avg_connect_within_top)
  summary.table$`Avg BC Connections (middle)`[1] = mean(subtable$avg_connect_between_top)
  summary.table$`Avg Node Degree (bottom)`[1] = mean(subtable$avg_node_degree_middle)
  summary.table$`Avg WC Connections (bottom)`[1] = mean(subtable$avg_connect_within_middle)
  summary.table$`Avg BC Connections (bottom)`[1] = mean(subtable$avg_connect_between_middle)
  
  results = helper1(substats)
  
  summary.table$`Avg Number of Predicted Comms (top)`[1] =results$top 
  summary.table$`Avg Number of Predicted Comms (middle)`[1] = results$middle
  summary.table$`Avg Bethe-Hessian Comms`[1] = mean(substats$Beth_Hessian_Comms)
          
  return(summary.table)
}

#debug(fill.in.avg.table)
#debug(helper1)


generate_summ_tables = function( flist = c(fp1, fp2, fp3, fp4, fp5, fp6, fp7)){
  
 
  master = list()
  summary.list.middle = list()
  summary.list.top = list()
  
  
  graph_types = c('small world', 'scale free', 'random graph')
  stdevs = c(0.1, 0.5)
  connect_type = c('disc', 'full')
  method = c('HCD', 'HC', 'Louvain')
  nm = c('Linear-GT', 'SoftKmeans-5-15', 'Linear-64-64', 'Linear-BH-64', 'GATCONV-BH-64', 'SAGECONV-BH-64', 'SAGECONV-BH-64-DW')
  all_data = vector('list', length = 7)
  names(all_data) = nm
  for (i in 1:length(flist)){
  
    data = read_data(flist[i])
    all_data[[i]] = data
    
    dt = data$data.top
    dm = data$data.mid
    
    dt$Method[which(dt$Method == 'HCD')] = nm[i] 
    dm$Method[which(dm$Method == 'HCD')] = nm[i] 
    
    master[[i]] = rbind.data.frame(cbind.data.frame(Layer = rep('Top Layer', dim(dt)[1]), 
                                                    Scenario = rep(nm[i], dim(dt)[1]),
                                                    dt), 
                                   cbind.data.frame(Layer = rep('Middle Layer', dim(dm)[1]), 
                                                    Scenario = rep(nm[i], dim(dt)[1]),
                                                    dm))
    
    for(j in 1:length(graph_types)){
      
      for(k in 1:length(stdevs)){
        
        for(q in 1:length(connect_type)){
          
          for(p in 1:length(method)){
            
            subdata.top = subset(data$data.top, 
                                 subgraph_type == graph_types[j] & StDev == stdevs[k] & connection_type == connect_type[q] & Method == method[p])
            
            
            subdata.mid = subset(data$data.mid, 
                                 subgraph_type == graph_types[j] & StDev == stdevs[k] & connection_type == connect_type[q] & Method == method[p])
            
            
            if (method[p] %in% c('HC', 'Louvain')){
              meth = method[p]
            }else{
              meth = nm[i]
            }
            
            
            temptable.top = fill.in.avg.table(subtable=subdata.top, 
                                              substats=data$stats, 
                                              method=meth, 
                                              gtype=graph_types[j], 
                                              stdev=stdevs[k], 
                                              ctype=connect_type[q])
            
            temptable.mid = fill.in.avg.table(subtable=subdata.mid, 
                                              substats=data$stats, 
                                              method=meth, 
                                              gtype=graph_types[j], 
                                              stdev=stdevs[k], 
                                              ctype=connect_type[q])
            
            temptable.mid$Scenario = nm[i]
            temptable.top$Scenario = nm[i]
            
            summary.list.top[[length(summary.list.top)+1]] = temptable.top
            summary.list.middle[[length(summary.list.middle)+1]] = temptable.mid
             
          }
        }
      }
    }
  }
  
  
  final.summary.top = do.call('rbind', summary.list.top)
  final.summary.mid = do.call('rbind', summary.list.middle)
  
  
  return(list(middle.tab = final.summary.mid, top.tab = final.summary.top, all.data = all_data, master = do.call('rbind', master)))
}


#debug(generate_summ_tables)

output = generate_summ_tables()


```





```{r, echo=FALSE, message=FALSE, warning=FALSE}


nm = c('Linear-GT', 'SoftKmeans-5-15', 'Linear-64-64', 'Linear-BH-64', 'GATCONV-BH-64', 'SAGECONV-BH-64', 'SAGECONV-BH-64-DW')



# final = rbind.data.frame(cbind.data.frame(Layer = rep('top', dim(output$top.tab)[1]), output$top.tab),
#                          cbind.data.frame(Layer = rep('middle', dim(output$top.tab)[1]), output$top.tab))

A = ggplot(data = output$master, 
           aes(x = Homogeneity, y = Completeness, fill = Method, shape = Method, color = Method))+
  #geom_bar(position = 'dodge2', stat = 'identity', alpha = 0.5, linewidth = 1.5)+
  #geom_boxplot(alpha = 0.5, linewidth = 1.2)+
  scale_shape_manual(values=c(21:25, 21:25))+
  scale_x_continuous(limits = c(0.5,1), breaks = seq(0.5, 1, 0.1))+
  scale_y_continuous(limits = c(0.5,1), breaks = seq(0.5, 1, 0.1))+
  geom_abline(slope = 1, intercept = 0, size = 1.5)+
  geom_point(size = 3, color = 'black')+
  facet_grid(Layer~Method)+
  #facet_wrap(~subgraph_type)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
        legend.position = 'top')+
  ggtitle("Clustering Performance")


plot(A)

```






```{r, echo=FALSE, message=FALSE, warning=FALSE}


#nm = c('Linear-GT','Linear-64-64', 'Linear-BH-64', 'GATCONV-BH-64', 'SAGECONV-BH-64', 'SAGECONV-BH-64-DW')



# final = rbind.data.frame(cbind.data.frame(Layer = rep('top', dim(output$top.tab)[1]), output$top.tab),
#                          cbind.data.frame(Layer = rep('middle', dim(output$top.tab)[1]), output$top.tab))

A = ggplot(data = subset(output$master, Layer == 'Top Layer'), 
           aes(x = Homogeneity, y = Completeness, fill = Method, shape = Method, color = Method))+
  #geom_bar(position = 'dodge2', stat = 'identity', alpha = 0.5, linewidth = 1.5)+
  #geom_boxplot(alpha = 0.5, linewidth = 1.2)+
  scale_shape_manual(values=c(21:25, 21:25))+
  scale_x_continuous(limits = c(0.4,1), breaks = seq(0.4, 1, 0.1))+
  scale_y_continuous(limits = c(0.4,1), breaks = seq(0.4, 1, 0.1))+
  geom_abline(slope = 1, intercept = 0, size = 1.5)+
  geom_point(size = 3, color = 'black')+
  facet_grid(`connection_type`~`subgraph_type`)+
  #facet_wrap(~subgraph_type)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
        legend.position = 'top')+
  ggtitle("Top Layer Clustering Performance")


plot(A)

```









```{r, echo=FALSE, message=FALSE, warning=FALSE}

A = ggplot(data = subset(output$master, subgraph_type == 'small world' & connection_type == 'disc'), 
           aes(x = Homogeneity, y = Completeness, fill = Method, shape = Method, color = Method))+
  #geom_bar(position = 'dodge2', stat = 'identity', alpha = 0.5, linewidth = 1.5)+
  #geom_boxplot(alpha = 0.5, linewidth = 1.2)+
  scale_shape_manual(values=c(21:25, 21:25))+
  scale_x_continuous(limits = c(0.5,1), breaks = seq(0.5, 1, 0.1))+
  scale_y_continuous(limits = c(0.5,1), breaks = seq(0.5, 1, 0.1))+
  geom_abline(slope = 1, intercept = 0, size = 1.5)+
  geom_point(size = 3, color = 'black')+
  facet_grid(Layer~Method)+
  #facet_wrap(~subgraph_type)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
        legend.position = 'top')+
  ggtitle("Clustering Performance For Small World Networks")


plot(A)



```


































































