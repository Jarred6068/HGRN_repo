---
title: "HCD Simulations Write Up"
author: "Audrey Fu Lab"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
  pdf_document: default
always_allow_html: true
bibliography: C:/Users/Bruin/OneDrive/Desktop/Research Assistantship/Thesis Proposal
  Defense/proposal_references.bib
number_sections: false
---

```{r setup, include=FALSE}

library(ggplot2)
library(ggthemes)
library(ggpubr)
library(latex2exp)
library(gridExtra)
library(knitr)
library(kableExtra)
library(dplyr)

knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=12, fig.height=8)

```


# Data Simulation {-}

### Simulating networks {-}
We adopt a top-down approach to simulate hierarchical networks, considering various simulation parameters such as graph sparsity, noise, and the architecture of the super-level graph(s), including small-world, scale-free, and random graph networks [@watts1998collective; @barabasi2003scale].

Our simulations focus on basic hierarchies comprising one or two hierarchical layers. Two-layer networks mirror classical community detection on graphs, where our aim is to recover the true community labels from a given graph. Meanwhile, three-layer networks present a more intricate scenario, where the bottom layer of the hierarchy contains two levels of community structure. Here, the top level corresponds to the nodes at the uppermost layer of the hierarchy, and the middle level consists of communities nested within the top-level communities. The objective with these networks is to identify both sets of community partitions.
	
In each hierarchy, for fully connected networks, we initiate by simulating $N_{\text{top}}$ top-level nodes, adhering to a directed small-world, random graph, or scale-free network architecture [@watts1998collective; @barabasi2003scale]. In cases where the network is disconnected, we simply simulate $N_{\text{top}}$ disconnected nodes. For networks with three hierarchical layers, we then generate a subnetwork of $N_{\text{middle}}$ nodes from each top-layer node, adhering to the network structure utilized at the top level. If the network is fully connected, we apply a probability $p_\text{between}$ to the nodes from different top-level communities being connected. 

The final step in all hierarchies is to generate the nodes in the observed (bottom) layer of the hierarchy. For each top-layer or middle-layer node, we generate a sub-network of $N_{\text{bottom}}$ nodes under the same sub-network structure as the previous layers, and we apply a probability $p_\text{between}$ for nodes from different communities to share an edge.


### Simulating gene expression {-}

Once we simulate a hierarchical graph, we utilize this hierarchy to generate the node-feature matrix, which depicts the expression of $N$ genes across $d$ samples. Here, $N$ denotes the number of nodes in the observed (bottom) layer of the hierarchy.

We simulate the node-feature matrix using the topological order of the observed level graph. We start by generating the features of nodes that have no parental input. We refer to these nodes as *origin* nodes. All origin nodes are simulated from a normal distribution with mean $0$ and standard deviation $\sigma$. All other nodes are simulated from a normal distribution centered at the mean of their parent nodes and with standard deviation $\sigma$. 

# Hierarchical Commuity Detection (HCD) Overview {-}

Our HCD method consists of two modules:

  1. A graph autoencoder based on the architecture proposed by @salehi2019graph which utilizes graph attention layers such as those first introduced by @velivckovic2017graph (See most recent version of pseudocode for details). In our applications, we incorporate multi-head attention in all encoder and decoder layers to expand model learning capacity. The graph autoencoder module takes a set of node attributes ${\bf X}\in\mathbb{R}^{N \times d}$ and an adjacency matrix ${\bf A}_{ij}\in[0,1]$ defining the relationships between the node as input and learns a low dimensional embedding ${\bf Z} \in \mathbb{R}^{N \times q}$ of the network and attributes. This embedding is then used to reconstruct the node attributes and adjacency matrix under a separate loss function for each.  
  
  2. The second module of HCD takes the embeddings ${\bf Z}$ generated by the autoencoder and applies a multilevel community detection process. This module first applies the function $f_{top}$ which partitions the data into $k$ groups. The function $f_{top}$ can be either (i) the $SoftKMeans$ layer described by [@Falkner2022] or a neural layer such as 
  
  **Simple Linear Layer**:
  
  $${\bf P} = f_{top}({\bf Z}) = \text{Softmax}(\theta({\bf ZW} + {\bf b}))$$
The above example is a simple fully connected layer where ${\bf W} \in \mathbb{R}^{N \times k}$ is a matrix of parameters, ${\bf b} \in \mathbb{R}^N$ is a bias parameter vector and $\theta$ is an activation function such as the $ReLU$ function. 

Alternative types of layer can also be used such heuristic KMeans or other GNN-type layers such as GraphSAGE convolution [@]. 

  **Using gradient optimized SoftKMeans**
  
  $${\bf P} = f_{top}({\bf Z}) = \text{Softmax}(g({\bf Z})) $$
where $g()$ represents the KMeans algorithm [@Falkner2022]
  
  **GraphSAGE Convolutional Layer**
  
  $${\bf p}_v = f_{top}({\bf z}_v) = \text{Softmax}\left(\theta\left( W Â· CONCAT\big({\bf z}_v,\ AGGREGATE\big({\bf z}_u : u \in N(v) \big) \big) \right)\right)$$
where ${\bf p}_v$ is the soft assignment of node $v$
  
# Simulation Study

Here we describe the settings for three different sets of simulations. For each set of simulations, we simulated hierarchical gene networks consisting of 5 top level nodes/communities, 15 middle level nodes/communities and 300 nodes/genes at the observed level of the hierarchy. We simulate networks for all three graph types (small world, scale free or random graph) with the nodes at the top level of the hierarchy either all connected or all disconnected. We also simulated nodes under two levels of noise with noise set to either $\sigma = 0.1$ or $\sigma = 0.5$. Additionally, we sample the probability for edges within and between node communities at the middle layer and bottom level from the uniform distributions


```{r simtab1, echo = FALSE, message=FALSE, warning=FALSE}

x = cbind.data.frame(Layer = c("Middle", "", "Bottom", ""),
                     Connection = c("Within", "Between", "Within", "Between"),
                     `Sampling Distibution` = rep('Uniform', 4),
                     `Lower Bound` = c(0.01, 0.01, 0.001, 0.001),
                     `Upper Bound` = c(0.15, 0.15, 0.05, 0.05))
kable(x, format = 'latex', booktabs = T)

```

Each combination of parameters (graph type, connectivity, and noise) is replicated multiple times. 




To evaluate the performance of HCD, we conducted a series of simulation studies under various conditions. Below, we describe each simulation condition in detail:

## Linear-GT
- **Description**: HCD employs linear neural layers for both the top and middle layer partitions. 
- **Setup**: 
  - Top layer output size: 5 (ground truth number of communities).
  - Middle layer output size: 15 (ground truth number of communities).
- **Purpose**: To assess performance when prior information about the true community structure is provided.

## SoftKmeans

## Linear

## GATCONV

## SAGECONV

---

# Summary

These simulation conditions are designed to rigorously assess the performance of HCD under diverse scenarios. By varying the partitioning methods, output sizes, and use of prior information, we aim to gain insights into HCD's robustness, adaptability, and effectiveness in uncovering hierarchical community structures in genomic data.



```{r paramtab1, echo = FALSE, message=FALSE, warning=FALSE}

params <- data.frame(
  Parameter = c("patience", "method", "batch learning", "batch_size", "AE operator", 
                "COMM operator", "attn. heads", "dropout", "Layer Normalization", 
                "AE hidden sizes", "Comm output size (Top)", "Comm output size (Middle)", 
                "$\\gamma$", "$\\delta$", "$\\lambda$", "learning rate", "Max epochs", 
                "Graph correlation cutoff", "% Training", "% Testing"),
  
  Value = c(10, "top down", "TRUE", 64, "GATv2Conv","Linear", 5, 0.2, "TRUE", "[256, 128]", 
            5, 15, 1, 1, "[1, 1]", 1e-3, 200, 0.2, 80, 20)
)

# Create kable table
kable(params,
      format = "latex",
      col.names = c("Parameter", "Value"),
      caption = "Simulation Set 1 model parameter settings") %>%
  kable_styling(full_width = FALSE)

```


### Evaluating performance {-}

We evaluate the performance of our HCD method using three graph-based clustering metrics:

   1. **homogeneity** evaluates the degree to which each predicted community contains only data points from a single true community, indicating how well the algorithm avoids mixing different groups. Thus, homogeneity tends to be high if resolved communities contain only members of the same true community.
   
   2. **completeness** assesses the extent to which all data points that belong to the same true
community are correctly assigned to a single predicted community. Thus completeness is always high if all members of the same true communities end up in the same resolved community even if several true communities are allocated together. 
   
   3. **NMI** Normalized Mutual Information (NMI) is a weighted average of the Completeness and Homogeneity two metrics. 
   
   4. **ARI** The Adjusted Rand Index (ARI) is a metric that measures the similarity between two different clusterings of the same data, correcting for the chance of random agreement. It ranges from -1 to 1, where 1 indicates perfect agreement between the clusterings, 0 represents random labeling, and negative values indicate less agreement than expected by chance. 


In all simulations we compare HCD with two commonly used heuristic methods:

  * **Louvain Method**: This widely used community detection algorithm optimizes modularity by iteratively reassigning nodes between communities and merging communities. It automatically determines the number of communities and is highly efficient for processing large networks. In all simulations, we apply the Louvain method to the estimated adjacency matrix, which is derived from the correlation matrix of the node features. The resulting community predictions are compared to the ground truth for both the top and middle layers of the simulated hierarchy.

  * **Hierarchical Clustering using Ward's Distance (HC)**: This agglomerative clustering approach iteratively merges clusters to minimize the increase in within-cluster variance. Ward's method tends to produce compact, spherical clusters and generates a dendrogram representing the full hierarchical structure of the data. In all simulations, HC is applied to the simulated gene expression data (node feature matrix). The optimal community predictions are determined by identifying the best cutting point on the dendrogram, aligning with the ground truth clusters (five clusters and 15 clusters).



 
### Ways of Estimating K

There are several classical approaches to estimating the number of communities, $k$, in unsupervised learning. Among these, two commonly adopted data-driven approaches are the **Elbow Method** and the optimization of a cluster quality metric, such as the **Silhouette Score**. Additionally, we also consider a graph-based approach known as the **Bethe Hessian estimate**.

- **Elbow Method**:  
  The Elbow Method identifies the optimal number of clusters by plotting the clustering cost (e.g., within-cluster sum of squares) against the number of clusters, $k$. The "elbow" point, where the rate of decrease in the cost slows significantly, is taken as the optimal $k$. This method assumes that beyond this point, adding more clusters does not improve clustering quality significantly.

- **Silhouette Method**:  
  The Silhouette Method evaluates the quality of clustering by measuring how similar data points are to their assigned cluster (cohesion) compared to other clusters (separation). The Silhouette score ranges from -1 to 1, where higher values indicate better-defined clusters. The optimal $k$ is the value that maximizes the average Silhouette score across all data points.

- **Bethe Hessian**:  
  The Bethe Hessian is a graph-based method for estimating the number of communities in a network. It involves constructing the Bethe Hessian matrix ${\bf B}_\eta = (\eta^2 - 1){\bf I} + {\bf D} - \eta {\bf A}$, where $A$ is the adjacency matrix, $D$ is the degree matrix, and $\eta$ is a regularization parameter. The number of negative eigenvalues of $H(r)$ provides an estimate of the number of communities. This approach leverages spectral properties of the graph to identify structural groupings. According to [@]

  
### Points to investigate



```{r, echo=FALSE, message=FALSE, warning=FALSE}
fp1 = 'C:/Users/Bruin/OneDrive/Documents/GitHub/HGRN_repo/Reports/Report_1_27_2025/Output/Intermediate_applications/combined_results_all_simulations.csv'

dtab = read.csv(fp1)

scene = 'BH-Linear'
meth = 'HCD-Linear'
subdat = subset(dtab, Scenario == scene & Method %in% c(meth, 'HC', 'Louvain'))

newdat = cbind.data.frame(HCD = subset(subdat, Method == meth & Layer == 'Middle Layer' & connection_type == 'disc')$ARI, HC = subset(subdat, Method == 'HC' & Layer == "Middle Layer" & connection_type == 'disc')$ARI)


A = ggplot(data = newdat, aes(x = HCD, y = HC))+
  scale_shape_manual(values=c(21:25, 21:25))+
  scale_x_continuous(limits = c(0.5,1), breaks = seq(0.5, 1, 0.1))+
  scale_y_continuous(limits = c(0.5,1), breaks = seq(0.5, 1, 0.1))+
  geom_abline(slope = 1, intercept = 0, size = 1.5)+
  geom_point(size = 3, color = 'black', alpha = 0.6)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
        legend.position = 'top')+
  ggtitle("Clustering Performance")


plot(A)

                
A = ggplot(data = subdat, aes(x = Homogeneity, y = Completeness, fill = Method, shape = Method, color = Method ))+
  scale_shape_manual(values=c(21:25, 21:25))+
  scale_x_continuous(limits = c(0.5,1), breaks = seq(0.5, 1, 0.1))+
  scale_y_continuous(limits = c(0.5,1), breaks = seq(0.5, 1, 0.1))+
  geom_abline(slope = 1, intercept = 0, size = 1.5)+
  geom_point(size = 3, color = 'black', alpha = 0.6)+
  facet_grid(subgraph_type~connection_type~Layer)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
        legend.position = 'top')+
  ggtitle("Clustering Performance")


plot(A)

```









```{r, echo=FALSE, message=FALSE, warning=FALSE}

scen = 'BH-NOL'
meth = 'HCD-NOL'

A = ggplot(data = subset(dtab, Scenario == scen & Method %in% c(meth, 'HC', 'Louvain') & connection_type == 'full' & subgraph_type == 'small world'), 
           aes(x = Method, y = NMI, fill = Method, linetype = as.factor(StDev)))+
  #geom_bar(position = 'dodge2', stat = 'identity', alpha = 0.5, linewidth = 1.5)+
  geom_boxplot(alpha = 0.5, linewidth = 1.2)+
  #scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  #geom_abline(slope = 1, intercept = 0, size = 1.5)+
  #geom_point(size = 3, color = 'black')+
  facet_grid(~Layer)+
  #facet_wrap(~subgraph_type)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
        legend.position = 'top')+
  ggtitle("Clustering Performance")
plot(A)



```


```{r, echo=FALSE, message=FALSE, warning=FALSE}

scen = 'BH-NOL'
meth = 'HCD-NOL'

A = ggplot(data = subset(dtab, Scenario == scen & Method %in% c(meth, 'HC', 'Louvain')), 
           aes(x = avg_connect_between_top, y = NMI, fill = Method, linetype = as.factor(StDev)))+
  #geom_bar(position = 'dodge2', stat = 'identity', alpha = 0.5, linewidth = 1.5)+
  #geom_boxplot(alpha = 0.5, linewidth = 1.2)+
  scale_y_continuous(limits = c(0,1), breaks = seq(0, 1, 0.1))+
  #geom_abline(slope = 1, intercept = 0, size = 1.5)+
  geom_point(size = 3, color = 'black')+
  facet_grid(Layer~connection_type~subgraph_type)+
  #facet_wrap(~subgraph_type)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
        legend.position = 'top')+
  ggtitle("Clustering Performance")
plot(A)

```




```{r, echo=FALSE, message=FALSE, warning=FALSE}


A = ggplot(data = subset(dtab, connection_type == 'full' & Scenario == 'BH'), 
           aes(x = Homogeneity, y = Completeness, fill = Method, shape = Method, color = Method))+
  #geom_bar(position = 'dodge2', stat = 'identity', alpha = 0.5, linewidth = 1.5)+
  #geom_boxplot(alpha = 0.5, linewidth = 1.2)+
  scale_shape_manual(values=c(21:25, 21:25))+
  scale_x_continuous(limits = c(0.5,1), breaks = seq(0.5, 1, 0.1))+
  scale_y_continuous(limits = c(0.5,1), breaks = seq(0.5, 1, 0.1))+
  geom_abline(slope = 1, intercept = 0, size = 1.5)+
  geom_point(size = 3, color = 'black')+
  facet_grid(Layer~subgraph_type~Method)+
  #facet_wrap(~subgraph_type)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90),
        legend.position = 'top')+
  ggtitle("Clustering Performance")


plot(A)

```































